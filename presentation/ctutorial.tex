\documentclass{beamer}
\usepackage{listings}
\usetheme{default}

\title{Interfacing C with OCaml}
\author{Niki Yoshiuchi}
\date{October 15, 2011}

\begin{document}

\begin{frame}[plain]
    \titlepage
\end{frame}

\begin{frame}{Overview}
\begin{itemize}
    \item Why?
    \item A Quick Example
    \begin{itemize}
        \item C Code
        \item OCaml Code
        \item Compiling
    \end{itemize}
    \item Function signatures
    \begin{itemize}
        \item Arity $>$ 5
    \end{itemize}
    \item value type
    \begin{itemize}
        \item Integral types
        \item Blocks
        \item Structured data
    \end{itemize}
    \item Linking
    \begin{itemize}
        \item Static
        \item Dynamic
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Why?}
\begin{itemize}
    \item Bindings to C libraries
    \item Multi-core threading
    \begin{itemize}
        \item If the C code doesn't require the OCaml runtime we can release the lock
    \end{itemize}
    \item Breaking the type system
    \begin{itemize}
        \item If you are going to do this, it's probably better to use the Obj module
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A Quick Example: C Code}
\begin{lstinputlisting}[language=C]{../quick/stubs.c}
\end{lstinputlisting}
\end{frame}

\begin{frame}[fragile]{A Quick Example: OCaml Code}
\begin{lstinputlisting}[language=ML]{../quick/main.ml}
\end{lstinputlisting}
\end{frame}

\begin{frame}[fragile]{A Quick Example: Compiling}
\begin{lstlisting}
gcc -I /usr/local/lib/ocaml -c stubs.c
ocamlc -c main.ml
ar rcs libstubs.a stubs.o
ocamlc -o main.byte -custom libstubs.a main.cmo
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Function Signatures}
The OCaml code is simple - declare your function using the \emph{external} keyword,
 specify its type and set it equal to the name of the C implementation.
\begin{itemize}
    \item OCaml:
    \begin{lstlisting}[language=ML]
    external name : type = "C-function-name"
    \end{lstlisting}
    \item C:
    \begin{lstlisting}[language=C]
    CAMLprim value name(value arg1, value arg2)
    \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,shrink=15]{Arity $>$ 5}
For functions with Arity n $>$ 5, we must implement two C functions - one
with n arguments and one with an array.  The former is used for native compilation,
the latter for byte code compilation.
\begin{itemize}
    \item OCaml:
    \begin{lstlisting}[language=ML]
    external name : type = "byte-code-name"
        "native-code-name"
    \end{lstlisting}
    \item C (native):
    \begin{lstlisting}[language=C]
    CAMLprim value native_code(value arg1, value arg2,
    value arg3, value arg4, value arg5, value arg6)
    \end{lstlisting}
    \item C (byte):
    \begin{lstlisting}[language=C]
    CAMLprim value byte_code(value *argv, int argc) {
        native_code(argv[0], argv[1], argv[2],
        argv[3], argv[4], argv[5]);
    }
    \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}{value type}
All variables passed between OCaml and C are of type \emph{value}.  A \emph{value} can be:
\begin{itemize} \item A integral type (unboxed) \item A pointer to a heap allocated object
    \item An pointer to a object allocated outside of the heap
\end{itemize}
There are two macros to help you determine what type is encapsulated in a \emph{value}
\begin{itemize}
    \item Is\_long(v) - returns true if v is an integral type
    \item Is\_block(v) - returns true if v is a pointer to a block
\end{itemize}
\end{frame}

\begin{frame}{integral types}
There are a number of macros for retreiving and storing integral types.
They are of the form \emph{Val\_type} (think "value of type") and \emph{Type\_val} (think "type of value")
\begin{itemize}
    \item Val\_long(l) and Long\_val(v)
    \item Val\_int(i) and Int\_val(i)
    \item Val\_bool(b), Val\_true, Val\_false and Bool\_val(v)
    \item Val\_unit
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Going back to our quick example}
Let's take another look at our quick example to see how these macros are used:
\begin{lstinputlisting}[language=C]{../quick/stubs.c}
\end{lstinputlisting}
\end{frame}

\begin{frame}{Blocks}
If a \emph{value} is a block, then it has a tag (accessible via the \emph{Tag\_val(v)} macro) which will
return one of the following values:
\begin{tabular}{| l | l |} \hline
    Tag & Description \\ \hline\hline
    0 to No\_scan\_tag-1 & A structured block.  Each field is a \emph{value}. \\ \hline
    Closure\_tag & A closure representing a functional value. \\ \hline
    String\_tag & A character string. \\ \hline
    Double\_tag & A double precision float. \\ \hline
    Abstract\_tag & An abstract datatype. \\ \hline
    Custom\_tag & A custom datatype. \\ \hline
\end{tabular}
\end{frame}

\end{document}
